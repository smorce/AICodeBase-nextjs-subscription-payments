async def run_parallel_research(self, research_state: dict):
        """サブグラフを並列かつ独立して動かす"""
        # --------------------------------------------
        # サブグラフで動かすエージェント3つ
        ##### 研究者 (gpt-researcher) - サブトピックについて詳細な調査を行い、草稿を書きます。
        ##### レビュー担当者           - follow_guidelines に基づいて下書きの正確性を検証し、フィードバックを提供します。
        ##### 校閲者                  - レビュー担当者のフィードバックに基づいて満足のいく内容になるまで下書きを修正します。
        # --------------------------------------------
        research_agent = ResearchAgent()
        reviewer_agent = ReviewerAgent()
        reviser_agent  = ReviserAgent()
        # --------------------------------------------
        queries = research_state.get("sections")           # サブトピック(アウトライントピック)のリスト。ちゃんと3つになっていた
        title = research_state.get("title")                # これは初期計画及びレポートのタイトルになる
        post_proxy = research_state.get("post_proxy")

        post_proxy.progress(f"デバッグ サブトピック(アウトライントピック)のリスト: {queries}\n")


        post_proxy.update_status("[doing]ResearchAgent🔎 & ReviewerAgent📑 & ReviserAgent📜: 各アウトライントピックについて並行してリサーチする")


        """
        後で消す。researcher_with_print が何故か3回呼び出されるし、3回目はreviewer_with_printが終わった後に呼び出される。ランググラフの謎仕様なのか、バグなのか？

        # 各エージェントの処理をラップする関数を定義
        async def researcher_with_print(state):
            post_proxy.update_status("[doing]ResearchAgent🔎: アウトライントピックを並列リサーチする")
            result = await research_agent.run_depth_research(state)
            post_proxy.update_status("[done]ResearchAgent🔎: アウトライントピックを並列リサーチする")
            return result

        async def reviewer_with_print(state):
            # task.json でガイドラインが False ならレビュー結果は None になる
            post_proxy.update_status("[doing]ReviewerAgent📑: レビューをする")
            result = reviewer_agent.run(state)   # 同期メソッドなので await しない
            post_proxy.update_status(f"[done]ReviewerAgent📑: レビューをする")
            return result

        async def reviser_with_print(state):
            # reviewer の結果が None なら 校閲者 は呼び出されない
            post_proxy.update_status("[doing]ReviserAgent📜: 校正する")
            result = reviser_agent.run(state)   # 同期メソッドなので await しない
            post_proxy.update_status("[done]ReviserAgent📜: 校正する")
            return result
        """
       
       ★ココ
        parent_step = cl.context.current_step
        print(f"デバッグ parent_step オブジェクト = {parent_step}")
        print(f"デバッグ parent_step.id = {parent_step.id}")
        print(f"デバッグ parent_step.name = {parent_step.name}")


       ★ココ
        async with cl.Step(name="ResearchAgent🔎 & ReviewerAgent📑 & ReviserAgent📜", parent_id=parent_step.id) as ThreeAgentStep:
            
            ThreeAgentStep.input = queries
            await ThreeAgentStep.stream_token('<span class="task-item pending">各アウトライントピックについて並行してリサーチする</span>', True)

            # ワークフローを定義
            workflow = StateGraph(DraftState)

            workflow.add_node("researcher", research_agent.run_depth_research)
            workflow.add_node("reviewer", reviewer_agent.run)
            workflow.add_node("reviser", reviser_agent.run)

            # set up edges researcher->reviewer->reviser->reviewer...
            workflow.set_entry_point("researcher")
            workflow.add_edge('researcher', 'reviewer')
            workflow.add_edge('reviser', 'reviewer')      # ループバック
            # 条件付きエッジ。レビュー担当者によるレビューメモが存在する場合、グラフは修正担当者に指示されます。そうでない場合、サイクルは最終草案で終了します。
            workflow.add_conditional_edges('reviewer',
                                            (lambda draft: "accept" if draft['review'] is None else "revise"),
                                            {"accept": END, "revise": "reviser"})

            chain = workflow.compile()

            # Execute the graph for each query in parallel
            print_agent_output(f"Running the following research tasks in parallel: {queries}...", agent="EDITOR")
            # ainvoke なので複数のクエリーに対して非同期かつ並列で実行。各アウトライン トピックについて並行して実行する
            final_drafts = [chain.ainvoke({"task": research_state.get("task"), "topic": query, "title": title})
                            for query in queries]
            # asyncio.gather なので全部のタスクが終了するまで次には行かない
            research_results = [result['draft'] for result in await asyncio.gather(*final_drafts)]

            await ThreeAgentStep.stream_token('<span class="task-item completed">各アウトライントピックについて並行してリサーチする</span>', True)



        # update_status が使えない理由は以下
        # 各エージェントの処理をラップする関数を定義して、そこで post_proxy.update_status() しているため、self.prev_content がガンガン更新されてしまい、「[doing]ResearchAgent ~~~ してリサーチする」 とは違う内容になっているから
        # → 強制的にメッセージをアップデートするメソッドを使う
        post_proxy.update_message(
                                "[doing]ResearchAgent🔎 & ReviewerAgent📑 & ReviserAgent📜: 各アウトライントピックについて並行してリサーチする",
                                "[done]ResearchAgent🔎 & ReviewerAgent📑 & ReviserAgent📜: 各アウトライントピックについて並行してリサーチする"
                                )

        # リターンするときに、ResearchState に対応する Kye の Value が更新される
        return {"research_data": research_results, "post_proxy":post_proxy}